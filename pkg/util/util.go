package util

import (
	"fmt"
	"io/ioutil"

	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/pkg/api"
	_ "k8s.io/client-go/pkg/api/install"
	"k8s.io/client-go/pkg/api/v1"
	_ "k8s.io/client-go/pkg/apis/apps/install"
	appsv1beta1 "k8s.io/client-go/pkg/apis/apps/v1beta1"
	_ "k8s.io/client-go/pkg/apis/extensions/install"
	extensionsv1beta1 "k8s.io/client-go/pkg/apis/extensions/v1beta1"

	"github.com/hashicorp/hcl"
)

func makeCodec(contentType string, pretty bool) (runtime.Codec, error) {
	serializerInfo, ok := runtime.SerializerInfoForMediaType(
		api.Codecs.SupportedMediaTypes(),
		contentType,
	)

	if !ok {
		return nil, fmt.Errorf("unable to create a serializer")
	}

	serializer := serializerInfo.Serializer

	if pretty && serializerInfo.PrettySerializer != nil {
		serializer = serializerInfo.PrettySerializer
	}

	codec := api.Codecs.CodecForVersions(
		serializer,
		serializer,
		schema.GroupVersions(
			[]schema.GroupVersion{
				v1.SchemeGroupVersion,
				extensionsv1beta1.SchemeGroupVersion,
				appsv1beta1.SchemeGroupVersion,
			},
		),
		runtime.InternalGroupVersioner,
	)

	return codec, nil
}

func Encode(object runtime.Object, contentType string, pretty bool) ([]byte, error) {
	codec, err := makeCodec(contentType, pretty)
	if err != nil {
		return nil, fmt.Errorf("kubegen/util: error creating codec for %q – %v", contentType, err)
	}

	data, err := runtime.Encode(codec, object)
	if err != nil {
		return nil, fmt.Errorf("kubegen/util: error encoding object to %q – %v", contentType, err)
	}

	return cleanup(contentType, data, pretty)
}

func EncodeList(list *api.List, contentType string, pretty bool) ([]byte, error) {
	// TODO use JSON for the first pass
	codec, err := makeCodec(contentType, pretty)
	if err != nil {
		return nil, fmt.Errorf("kubegen/util: error creating codec for %q – %v", contentType, err)
	}
	// XXX: uncommenting this results in the following error:
	// json: error calling MarshalJSON for type runtime.RawExtension: invalid character 'a' looking for beginning of value
	//if err := runtime.EncodeList(codec, list.Items); err != nil {
	//	return nil, err
	//}

	data, err := runtime.Encode(codec, list)
	if err != nil {
		return nil, fmt.Errorf("kubegen/util: error encoding list to %q – %v", contentType, err)
	}

	return cleanup(contentType, data, pretty)
}

func DumpListToFiles(list *api.List, contentType string) ([]string, error) {
	filenames := []string{}
	for _, item := range list.Items {
		var (
			name, filename, filenamefmt string
		)

		switch item.GetObjectKind().GroupVersionKind().Kind {
		case "Service":
			filenamefmt = "%s-svc.%s"
			name = item.(*v1.Service).ObjectMeta.Name
		case "Deployment":
			filenamefmt = "%s-dpl.%s"
			name = item.(*extensionsv1beta1.Deployment).ObjectMeta.Name
		case "ReplicaSet":
			filenamefmt = "%s-rs.%s"
			name = item.(*extensionsv1beta1.ReplicaSet).ObjectMeta.Name
		case "DaemonSet":
			filenamefmt = "%s-ds.%s"
			name = item.(*extensionsv1beta1.DaemonSet).ObjectMeta.Name
		case "StatefulSet":
			filenamefmt = "%s-ss.%s"
			name = item.(*appsv1beta1.StatefulSet).ObjectMeta.Name
		}

		data, err := Encode(item, contentType, true)
		if err != nil {
			return nil, err
		}

		switch contentType {
		case "application/yaml":
			filename = fmt.Sprintf(filenamefmt, name, "yaml")
			data = append([]byte(fmt.Sprintf("# generated by kubegen\n# => %s\n---\n", filename)), data...)
		case "application/json":
			filename = fmt.Sprintf(filenamefmt, name, "yaml")
		}

		if err := ioutil.WriteFile(filename, data, 0644); err != nil {
			return nil, fmt.Errorf("kubegen/util: error writing to file %q – %v", filename, err)
		}
		filenames = append(filenames, filename)
	}

	return filenames, nil
}

func NewFromHCL(obj interface{}, data []byte) error {
	manifest, err := hcl.Parse(string(data))
	if err != nil {
		return fmt.Errorf("kubegen/util: error parsing HCL – %v", err)
	}

	if err := hcl.DecodeObject(obj, manifest); err != nil {
		return fmt.Errorf("kubegen/util: error constructing an object from HCL – %v", err)
	}

	return nil
}
